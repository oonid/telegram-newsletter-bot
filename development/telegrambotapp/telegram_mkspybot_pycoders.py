# -*- coding: utf-8 -*-
"""telegram_mkspybot_pycoders.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Dv2qjYjoBKQgvVobj2FQy-joE6JfmJHI
"""

import requests
import json
from lxml import html, etree

KEY='1620431066:xxx'  # please check on the group
ENDPOINT='https://api.telegram.org/bot{}'.format(KEY)
pycoders = 'https://pycoders.com'

# functions related to telegram

def get_telegram_message():
    json_message = None
    response = requests.get('{}/getUpdates'.format(ENDPOINT))
    if response.ok:  # HTTP 200
        message = response.text
        json_message = json.loads(message)
    else:
        print('response status: {}'.format(response.status_code))
    return json_message

def get_message_chat_id(message):
    message_chat_id = None
    if 'message' in message and 'chat' in message['message'] and \
            'id' in message['message']['chat']:
        # currently only reply to group, not personal chat
        if message['message']['chat']['type'] == 'supergroup':
            message_chat_id = message['message']['chat']['id']
    return message_chat_id

def get_message_text(message):
    message_text = None  # for example "new_chat_members" has no text
    if 'message' in message and 'text' in message['message']:
        message_text = message['message']['text']
    return message_text

def is_message_get_update(message):
    is_get_update = False
    message_text = get_message_text(message)
    if message_text and message_text.startswith('/update'):  # not None
        is_get_update = True
    return is_get_update

def post_message_html(to_chat_id, text):
    if to_chat_id and text:  # must be not None
        data = {
            'chat_id': to_chat_id,
            'text': text,
            'parse_mode': 'HTML',
        }

        # data dict will automatically converted to json by requests library
        response = requests.post('{}/sendMessage'.format(ENDPOINT), json=data)
        if response.ok:
            message = response.text
            print(message)
        else:
            print('response status: {} msg: {}'
                .format(response.status_code, response.text))

# functions related to scraping pycoders

def get_tree_main_page():
    tree = None
    response = requests.get(pycoders)
    if response.ok:  # HTTP 200
        tree = html.fromstring(response.text)
    return tree

def get_tree_latest_issue():
    tree = None
    tree_main_page = get_tree_main_page()
    if tree_main_page:
        latest_issue = None
        iframes = tree_main_page.xpath('//iframe')
        for iframe in iframes:
            iframe_src = iframe.get('src')
            print(iframe_src)
            if 'issues' in iframe_src:
                if pycoders in iframe_src:  # absolute URL
                    latest_issue = iframe_src
                else:  # relative URL
                    latest_issue = '{}{}'.format(pycoders, iframe_src)
        if latest_issue:  # got latest issue URL, not None
            response = requests.get(latest_issue)
            tree = html.fromstring(response.text)
    return tree

def get_pycoders_links_as_dict():
    links = {}
    tree = get_tree_latest_issue()
    if tree:
        tds = tree.xpath('//td[@class="mcnTextContent"]')
        for td in tds:
            if len(td) == 0:  # no child (title, issue info)
                print('title: {}'.format(td.text.strip()))
            elif len(td) == 1:  # 1 child (issue URL)
                ahrefs = td.xpath('./a')
                if len(ahrefs) == 1:
                    print('url: {}'.format(ahrefs[0].get('href')))
            elif len(td) == 3:  # 3 childs (footer, copyright)
                print(td.text.strip())

            else:  # many childs
                print(len(td))
                # print(etree.tostring(td, pretty_print=True))
                for elmt in td.iter('a'):  # instead of td.iter()
                    # print(etree.tostring(elmt, pretty_print=True))
                    ahref = elmt.get('href')
                    if ahref in links and elmt.text:  # exists
                        links[ahref].append(elmt.text.strip())
                    else:  # not yet exists
                        # print(elmt.text)
                        links[ahref] = [elmt.text.strip()] if elmt.text else []
    return links

def get_pycoders_as_html_message():
    html_message = None
    links = get_pycoders_links_as_dict()
    if links:  # got all links, not None
        messages = []
        for k, v in links.items():
            if k and v:  # both not empty
                # print(k, v)
                messages.append('<a href="{}">{}</a>'.format(k, ', '.join(v)))
        if messages:  # not empty
            html_message = 'Summary of {}\n\n{}' \
                           .format(pycoders, '\n'.join(messages))
    return html_message

# main

pycoders_message = None

msgs = get_telegram_message()
if msgs and 'result' in msgs:  # not None
    for msg in msgs['result']:
        # print(json.dumps(msg, indent=4, sort_keys=True))
        if is_message_get_update(msg):  # process only if group ask for update
            message_chat_id = get_message_chat_id(msg)
            if message_chat_id:
                print('\n\nSTART')
                print(message_chat_id)
                if not pycoders_message:  # still empty yet
                    print(pycoders_message)
                    pycoders_message = get_pycoders_as_html_message()
                if pycoders_message:  # if success scraping pycoders
                    print(pycoders_message)
                    post_message_html(message_chat_id, pycoders_message)

